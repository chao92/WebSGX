<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Demo page</title>
	<link href="css/bootstrap.min.css" rel="stylesheet">
	<style type="text/css">
		div.result {
			background-color: #cccccc;
			word-wrap: break-word;
		}

		.cyphertext {
			word-wrap: break-word;
		}
	</style>

</head>

<body>
	<div class="container">
		<div class="page-header">
			<h1>Computing Demo <small>Client Attestation</small></h1>
			<p>vk_key: shared secret key for REPORT_DATA<br>mk_key: shared secret key for generating MAC's <br> sk_key: shared secret key for encryption<br>smk_key: used only for SIGMA protocol</p>
		</div>

		<h2>Client</h2>
		<div class="row">
			<div class="col-md-4">
				<button id="A_btn_start_Attestation" class="btn btn-primary">Start Attestation</button>
				
			</div>
			<div class="col-md-7 col-md-offset-1 result">
				<h3>Input is: </h3>
				<p>username: <span id="client_username" class="ciphertext">user1</span> </p>
				<p>password: <span id="client_password" class="ciphertext">13313</span> </p>
				<p>SSL Setting: <span id="client_password" class="ciphertext">nSSL</span> </p>
				<p>Client Private Key (for signing ga_gb): <span id="client_private key" class="ciphertext">018c03d1533457adeaaeb6653b6a861fec879c4311de663bcea1522dbb6ce790</span> </p>
				<h3>Extract Public key send from server and GID from Received MSG1 </h3>
				<p>Client Received MSG1: <span id="A_RECEIVED MSG1" class="ciphertext"></span> </p>
				<p>RECEIVED ga_x: <span id="A_RECEIVED_ga_x" class="ciphertext"></span> </p>
				<p>RECEIVED ga_y: <span id="A_RECEIVED_ga_y" class="ciphertext"></span> </p>
				<p>RECEIVED GID: <span id="A_RECEIVED_GID" class="ciphertext"></span> </p>
				<h3>Construct MSG2 </h3>
				<p>Client Public Key: <span id="A_ECCDH_public_key" class="ciphertext"></span></p>
				<p>Client Private Key: <span id="A_ECCDH_private_key" class="ciphertext"></span></p>
				<p>Client Shared_key: <span id="A_ECCDH_shared_key" class="ciphertext"></span> </p>
				<p>Client derived smk_key: <span id="A_ECCDH_derived_smk_key" class="ciphertext"></span> </p>
				<p>Client derived sk_key: <span id="A_ECCDH_derived_sk_key" class="ciphertext"></span> </p>
				<p>Client derived mk_key: <span id="A_ECCDH_derived_mk_key" class="ciphertext"></span> </p>
				<p>Client derived vk_key: <span id="A_ECCDH_derived_vk_key" class="ciphertext"></span> </p>

			</div>
		</div>

		<h3>Acknowledgements</h3>
		A large part of the work on the jspaillier library was done at <a href="http://www.tno.nl">TNO</a> in a project supported by the <a href="http://www.commit-nl.nl">COMMIT</a> program.
	</div>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>

	<!-- add AES-CMAC -->
	<script type="text/javascript" src="cryptojs-extension-master/lib/cryptojs-aes.min.js"></script>
	<script type="text/javascript" src="cryptojs-extension-master/build/cmac.min.js"></script>
	<!-- test web crypto  -->
	<script type="text/javascript" src="js/webcrypto.js"></script>
	<script type="text/javascript" src="js/client_main.js"></script>
	<script type="text/javascript" src="js/attestation_client.js"></script>
	
	<!-- end of web crypto -->
	<script type="text/javascript">
		
		$(function() {

		//Client
		$('#A_btn_start_Attestation').click(function(event) {

			var A_RECEIVED_ga_x='';
			var A_RECEIVED_ga_y='';
			var GID='';

			console.log("click start attestation button");
			var postdata = {'username': "user1",
			'password': "13313",
			'SSL':"nSSL",
			'privateKey' : "018c03d1533457adeaaeb6653b6a861fec879c4311de663bcea1522dbb6ce790"};
			$.ajax({
				type: "POST",
				url: "test.php",
				data: postdata,
				dataType: "JSON",
				success : function(text){

					// console.log(text['ga_x']);
					// console.log(text['ga_y']);
					// console.log(text['GID']);
					A_RECEIVED_ga_x=text['ga_x'];
					A_RECEIVED_ga_y=text['ga_y'];
					GID = text['GID'];
					$('#A_RECEIVED_ga_x').html(A_RECEIVED_ga_x);
					$('#A_RECEIVED_ga_y').html(A_RECEIVED_ga_y);
					$('#A_RECEIVED_GID').html(GID);

					// then generating MSG2 keys
					window.crypto = window.crypto || window.msCrypto; //for IE11
					if(window.crypto.webkitSubtle) {
			              window.crypto.subtle = window.crypto.webkitSubtle; //for Safari
			        }
			          if (window.crypto.subtle) {
			          	promise_key = window.crypto.subtle.generateKey({name: "ECDH", namedCurve: "P-256",}, true, ["deriveKey", "deriveBits"]);
			          	promise_key.then(function(key) {
			          		A_private_key_object = key.privateKey;
			          		A_public_key_object = key.publicKey;

							exported_public_key = crypto.subtle.exportKey("jwk", A_public_key_object);//base64url encoding
							exported_public_key.then(function(key) {
										//returns the exported key data

										var plainKey = "<br> x: " + Base64URL2HEX(key.x) +"<br>"+ "y: " + Base64URL2HEX(key.y);
										A_public_key_x_exported = hexStringToByte(Base64URL2HEX(key.x));
										A_public_key_y_exported = hexStringToByte(Base64URL2HEX(key.y));

										// console.log("Key is");
										// console.log(key)

										$('#A_ECCDH_public_key').html(plainKey);


									});
							exported_public_key.catch = function(e) {
								console.log(e.message);
							}

							exported_priv_key = window.crypto.subtle.exportKey("jwk", A_private_key_object);//base64url encoding
							exported_priv_key.then(function(key) {
										//returns the exported key data
										// console.log("private key");

										// A_private_key_exported = hexStringToByte(Base64URL2HEX(key.d));

										$('#A_ECCDH_private_key').html(Base64URL2HEX(key.d));
										console.log(key);

									});
							exported_priv_key.catch = function(e) {
								console.log(e.message);
							}
						});
			          	promise_key.catch = function(e) {
			          		console.log(e.message);
			          	}

						// import public key based on ga_x, ga_y
						console.log("before imported server passed public key, check the x and y is")
						var x_tmp = HEX2Base64URL(A_RECEIVED_ga_x);
						// var x_tmp = HEX2Base64URL(strrev(A_RECEIVED_ga_x));
						console.log(A_RECEIVED_ga_x);
						console.log("Hex2base64 x: ");
						console.log(x_tmp);
						console.log(A_RECEIVED_ga_y);
						var y_tmp = HEX2Base64URL(A_RECEIVED_ga_y);
						// var y_tmp = HEX2Base64URL(strrev(A_RECEIVED_ga_y));
						console.log("Hex2base64 y: ");
						console.log(y_tmp);
						// public_ga_key = crypto.subtle.importKey( "jwk",{kty: "EC", crv: "P-256", x: HEX2Base64URL(A_RECEIVED_ga_x), y: HEX2Base64URL(A_RECEIVED_ga_y), ext: true}, {name: "ECDH", namedCurve: "P-256",},false, []);
						// public_ga_key.then(function (publicKey) {
						// 	console.log("improted public key is");
						// 	console.log(publicKey);
						// 	server_public_key = publicKey
						// })
						window.crypto.subtle.importKey(
						    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
						    {   //this is an example jwk key, other key types are Uint8Array objects
						    	kty: "EC",
						    	crv: "P-256",
						        // x: HEX2Base64URL(A_RECEIVED_ga_x),
						        // y: HEX2Base64URL(A_RECEIVED_ga_y),
						        // d: "",
						        x: x_tmp,
						        y: y_tmp,
						        // d: "250dDOHq0N-P7fevM9XBfQ9fpICqDgnYk2vX0w8Ci-c",
						        ext: true,
						    },
						    {   //these are the algorithm options
						    	name: "ECDH",
						        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
						    },
						    false, //whether the key is extractable (i.e. can be used in exportKey)
						    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
						    )
						.then(function(publicKey){
						    //returns a privateKey (or publicKey if you are importing a public key)
						    console.log("improted public key is");
						    console.log(publicKey);

							//derived shared key using client itself private key (just generated above) and Server's public key g_a
							A_comput_shared_dhkey(A_private_key_object, publicKey);



							// convert derived key to hexdecimal
							// console.log("show shared key");
							var tmp_dh_key = convertArrayBufferToHexaDecimal(new Uint8Array(B_derived_key));
							console.log(tmp_dh_key);
						})
						.catch(function(e){
							console.error(e);
							// console.log('error_name: '+e.name+' error_message: ' + e.message);
							// console.log('description: '+e.description+' error_number: '+e.number);
							// console.log(e.toSource()+" "+e.toString());
						});


					} else {
						alert("Cryptography API not Supported");
					}
					
				},
				error: function(xhr, textStatus, errorThrown) {
					console.log('ajax loading error...');
					return false;
				}
			});

		});// end of Client

});
</script>
</body>

</html>