<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Demo page</title>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <style type="text/css">
        div.result {
            background-color: #cccccc;
            word-wrap: break-word;
        }
        .cyphertext {
            word-wrap: break-word;
        }
    </style>

</head>

<body>
    <div class="container">
        <div class="page-header">
            <h1>Computing Demo <small>Client Attestation</small></h1>
            <p>vk_key: shared secret key for REPORT_DATA
                <br>mk_key: shared secret key for generating MAC's
                <br> sk_key: shared secret key for encryption
                <br>smk_key: used only for SIGMA protocol</p>
        </div>

        <h2>Client</h2>
        <div class="row">
            <div class="col-md-4">
                <button id="A_btn_start_Attestation" class="btn btn-primary">Start Attestation</button>

            </div>
            <div class="col-md-7 col-md-offset-1 result">
                <h3>Input is: </h3>
                <p>username: <span id="client_username" class="ciphertext">user1</span> </p>
                <p>password: <span id="client_password" class="ciphertext">13313</span> </p>
                <p>SSL Setting: <span id="client_password" class="ciphertext">nSSL</span> </p>
                <p>Client Private Key (for signing ga_gb): <span id="client_private key" class="ciphertext">018c03d1533457adeaaeb6653b6a861fec879c4311de663bcea1522dbb6ce790</span> </p>
                <h3>Extract Public key send from server and GID from Received MSG1 </h3>
                <p>Client Received MSG1: <span id="A_RECEIVED MSG1" class="ciphertext"></span> </p>
                <p>RECEIVED ga_x: <span id="C_RECEIVED_ga_x" class="ciphertext"></span> </p>
                <p>RECEIVED ga_y: <span id="C_RECEIVED_ga_y" class="ciphertext"></span> </p>
                <p>RECEIVED GID: <span id="C_RECEIVED_GID" class="ciphertext"></span> </p>
                <h3>Construct MSG2 </h3>
                <p>Client Public Key: <span id="C_ECCDH_public_key" class="ciphertext"></span>
                </p>
                <p>Client Private Key: <span id="C_ECCDH_private_key" class="ciphertext"></span>
                </p>
                <p>Client Shared_key: <span id="C_ECCDH_shared_key" class="ciphertext"></span> </p>
                <p>Client derived smk_key: <span id="C_ECCDH_derived_smk_key" class="ciphertext"></span> </p>
                <p>Client derived sk_key: <span id="C_ECCDH_derived_sk_key" class="ciphertext"></span> </p>
                <p>Client derived mk_key: <span id="C_ECCDH_derived_mk_key" class="ciphertext"></span> </p>
                <p>Client derived vk_key: <span id="C_ECCDH_derived_vk_key" class="ciphertext"></span> </p>

            </div>
        </div>

        <h3>Acknowledgements</h3> A large part of the work on the jspaillier library was done at <a href="http://www.tno.nl">TNO</a> in a project supported by the <a href="http://www.commit-nl.nl">COMMIT</a> program.
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>

    <!-- add AES-CMAC -->
    <script type="text/javascript" src="cryptojs-extension-master/lib/cryptojs-aes.min.js"></script>
    <script type="text/javascript" src="cryptojs-extension-master/build/cmac.min.js"></script>
    <!-- test web crypto  -->
    <script type="text/javascript" src="js/webcrypto.js"></script>
    <!-- end of web crypto -->

    <script type="text/javascript">
        $(function() {

            //Client
            $('#A_btn_start_Attestation').click(function(event) {

                // received from msg1
                var C_RECEIVED_ga_x;
                var A_RECEIVED_ga_y;
                var C_RECEIVED_GID;

                // generated key pair
                var C_private_key_object;
                var C_public_key_object;

                // shared key generated by ga_x, C_private_key_object
                var dh_shared_key; // bits

                var C_smk_key; // padding 0
                var C_mk_key; // padding 2
                var C_sk_key; // padding 1
                var C_vk_key; // padding 3

                var ga; // received from msg1
                var gb; // generated by client

                var C_privateKey = "018c03d1533457adeaaeb6653b6a861fec879c4311de663bcea1522dbb6ce790";
                var C_privateKey_x = "72128a7a17526ebf85d03a623730aead3e3daaee9c60731db05be8621c4beb38";
                var C_privateKey_y = "d48140d950e2577b26eeb741e7c614e224b7bdc903f29a28a83cc81011145e06";

                console.log("click start attestation button");
                var msg1_request_data = {
                    'username': "user1",
                    'password': "13313",
                    'SSL': "nSSL",
                    // 'privateKey': "018c03d1533457adeaaeb6653b6a861fec879c4311de663bcea1522dbb6ce790"
                };
                $.ajax({
                    type: "POST",
                    url: "get_MSG1.php",
                    data: msg1_request_data,
                    dataType: "JSON",
                    success: function(text) {

                        console.log(text);

                        C_RECEIVED_ga_x = text['ga_x'];
                        C_RECEIVED_ga_y = text['ga_y'];
                        C_RECEIVED_GID = text['GID'];

                        // ga is transformed to big-endiness before server sent because webcyrot accpt big-endienss

                        ga = new Uint8Array(64);
                        ga.set(hexStringToByte(C_RECEIVED_ga_x), 0);
                        ga.set(hexStringToByte(C_RECEIVED_ga_y), hexStringToByte(C_RECEIVED_ga_x).byteLength);

                        $('#C_RECEIVED_ga_x').html(C_RECEIVED_ga_x);
                        $('#C_RECEIVED_ga_y').html(C_RECEIVED_ga_y);
                        $('#C_RECEIVED_GID').html(C_RECEIVED_GID);

                        // then generating MSG2 keys
                        window.crypto = window.crypto || window.msCrypto; //for IE11
                        if (window.crypto.webkitSubtle) {
                            window.crypto.subtle = window.crypto.webkitSubtle; //for Safari
                        }
                        if (window.crypto.subtle) {
                            window.crypto.subtle.generateKey({
                                    name: "ECDH",
                                    namedCurve: "P-256",
                                }, true, ["deriveKey", "deriveBits"])
                                .then(function(key) {
                                    C_private_key_object = key.privateKey;
                                    C_public_key_object = key.publicKey;

                                    window.crypto.subtle.exportKey("jwk", C_public_key_object) //base64url encoding
                                        .then(function(key) {
                                            //returns the exported key data

                                            var plainKey = "<br> x: " + Base64URL2HEX(key.x) + "<br>" + "y: " + Base64URL2HEX(key.y);
                                            gb = new Uint8Array(64);
                                            var tmp_public_key_x_exported = hexStringToByte(Base64URL2HEX(key.x));
                                            var tmp_public_key_y_exported = hexStringToByte(Base64URL2HEX(key.y));

                                            // or changeEndian
                                            // var tmp_public_key_x_exported = hexStringToByte(changeEndian(Base64URL2HEX(key.x)));
                                            // var tmp_public_key_y_exported = hexStringToByte(changeEndian(Base64URL2HEX(key.y)));
                                            
                                            gb.set(tmp_public_key_x_exported, 0);
                                            gb.set(tmp_public_key_y_exported, tmp_public_key_x_exported.byteLength);

                                            console.log("big-endienss gb is");
                                            console.log(gb);

                                            $('#C_ECCDH_public_key').html(plainKey);

                                        }).catch = function(e) {
                                            console.log("export public key error");
                                            console.log(e.message);
                                        }

                                    window.crypto.subtle.exportKey("jwk", C_private_key_object) //base64url encoding
                                        .then(function(key) {

                                            $('#C_ECCDH_private_key').html(Base64URL2HEX(key.d));
                                            console.log(key);

                                        }).catch = function(e) {
                                            console.log("export public key error");
                                            console.log(e.message);
                                        }
                                }).catch = function(e) {
                                    console.log("generate key error");
                                    console.log(e.message);
                                }

                            window.crypto.subtle.importKey(
                                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                                    { //this is an example jwk key, other key types are Uint8Array objects
                                        kty: "EC",
                                        crv: "P-256",
                                        x: HEX2Base64URL(C_RECEIVED_ga_x),
                                        y: HEX2Base64URL(C_RECEIVED_ga_y),
                                        // d: "250dDOHq0N-P7fevM9XBfQ9fpICqDgnYk2vX0w8Ci-c",
                                        ext: true,
                                    }, { //these are the algorithm options
                                        name: "ECDH",
                                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                                    },
                                    false, //whether the key is extractable (i.e. can be used in exportKey)
                                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                                )
                                .then(function(publicKey) {
                                    //returns a privateKey (or publicKey if you are importing a public key)
                                    console.log("improted public key is");
                                    console.log(publicKey);

                                    //derived shared key using client itself private key (just generated above) and Server's public key g_a
                                    // A_comput_shared_dhkey(A_private_key_object, publicKey);
                                    window.crypto.subtle.deriveBits({
                                                name: "ECDH",
                                                namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                                                public: publicKey, //an ECDH public key from generateKey or importKey
                                            },
                                            C_private_key_object, //your ECDH private key from generateKey or importKey
                                            256)
                                        .then(function(bits) {
                                            dh_shared_key = new Uint8Array(bits);
                                            console.log(dh_shared_key);

                                            $('#C_ECCDH_shared_key').html(convertArrayBufferToHexaDecimal(bits));

                                            // smk is only needed for msg2 generation
                                            var key = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');
                                            var smk_key_tmp = new Uint8Array(dh_shared_key.byteLength + 1);
                                            smk_key_tmp.set(dh_shared_key, 0);
                                            smk_key_tmp.set([0], dh_shared_key.byteLength); // padding 0 to the end of shared key
                                            // console.log(smk_key_tmp);
                                            // console.log(byteToHexString(smk_key_tmp));
                                            C_smk_key = CryptoJS.CMAC(key, byteToHexString(smk_key_tmp)).toString();
                                            $('#C_ECCDH_derived_smk_key').html(C_smk_key);

                                            // mk for future communication
                                            // var key = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');
                                            var mk_key_tmp = new Uint8Array(dh_shared_key.byteLength + 1);
                                            mk_key_tmp.set(dh_shared_key, 0);
                                            mk_key_tmp.set([2], dh_shared_key.byteLength); // padding 2 to the end of shared key
                                            // console.log(mk_key_tmp);
                                            // console.log(byteToHexString(mk_key_tmp));
                                            C_mk_key = CryptoJS.CMAC(key, byteToHexString(mk_key_tmp)).toString();
                                            $('#C_ECCDH_derived_mk_key').html(C_mk_key);

                                            // sk for future communication
                                            // var key = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');
                                            var sk_key_tmp = new Uint8Array(dh_shared_key.byteLength + 1);
                                            sk_key_tmp.set(dh_shared_key, 0);
                                            sk_key_tmp.set([1], dh_shared_key.byteLength); // padding 1 to the end of shared key
                                            // console.log(sk_key_tmp);
                                            // console.log(byteToHexString(sk_key_tmp));
                                            C_sk_key = CryptoJS.CMAC(key, byteToHexString(sk_key_tmp)).toString();
                                            $('#C_ECCDH_derived_sk_key').html(C_sk_key);

                                            // smk is only needed for msg2 generation
                                            // var key = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');
                                            var vk_key_tmp = new Uint8Array(dh_shared_key.byteLength + 1);
                                            vk_key_tmp.set(dh_shared_key, 0);
                                            vk_key_tmp.set([3], dh_shared_key.byteLength); // padding 3 to the end of shared key
                                            // console.log(vk_key_tmp);
                                            // console.log(byteToHexString(vk_key_tmp));
                                            C_vk_key = CryptoJS.CMAC(key, byteToHexString(vk_key_tmp)).toString();
                                            $('#C_ECCDH_derived_vk_key').html(C_vk_key);

                                            // create gb_ga
                                            var gb_ga = new Uint8Array(128);
                                            gb_ga.set(gb, 0);
                                            gb_ga.set(ga, gb.byteLength);

                                            // for now, gb, ga are all big-endiness

                                            var gb_ga_little_endian = new Uint8Array(128);
                                            gb_ga_little_endian.set(unitArrayChangeEndian(gb),0);
                                            gb_ga_little_endian.set(unitArrayChangeEndian(ga),gb.byteLength);
                                            


                                            // console.log(gb_ga);

                                            //sign gb_ga by client privateKey

                                            console.log("format of C_RECEIVED_ga_x");
                                            console.log(C_RECEIVED_ga_x);
                                            console.log("format of C_privateKey_x");
                                            // console.log(changeEndian(C_privateKey_x));
                                            window.crypto.subtle.importKey(
                                                    "jwk", //can be "jwk" (public or private), "spki" (public only), or "pkcs8" (private only)
                                                    { //this is an example jwk key, other key types are Uint8Array objects
                                                        kty: "EC",
                                                        crv: "P-256",
                                                        x: HEX2Base64URL(changeEndian(C_privateKey_x)),
                                                        y: HEX2Base64URL(changeEndian(C_privateKey_y)),
                                                        d: HEX2Base64URL(C_privateKey),
                                                        // x: HEX2Base64URL(C_privateKey_x),
                                                        // y: HEX2Base64URL(C_privateKey_y),
                                                        // d: HEX2Base64URL(C_privateKey),
                                                        ext: true,
                                                    }, { //these are the algorithm options
                                                        name: "ECDSA",
                                                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                                                    },
                                                    false, //whether the key is extractable (i.e. can be used in exportKey)
                                                    ["sign"] //"verify" for public key import, "sign" for private key imports
                                                )
                                                .then(function(privateKey) {
                                                    //returns a publicKey (or privateKey if you are importing a private key)
                                                    console.log(privateKey);
                                                    // sgin gb_ga with improted privateKey
                                                    window.crypto.subtle.sign({
                                                                name: "ECDSA",
                                                                hash: {
                                                                    name: "SHA-256"
                                                                }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
                                                            },
                                                            privateKey, //from generateKey or importKey above
                                                            // gb_ga //ArrayBuffer of data you want to sign 
                                                            gb_ga_little_endian
                                                        )
                                                        .then(function(signature) {
                                                            //returns an ArrayBuffer containing the signature
                                                            console.log("signature");
                                                            var msg2_sign_gb_ga = new Uint8Array(signature);
                                                            console.log(new Uint8Array(signature));

                                                            var msg2_sign_gb_ga_little_endian = unitArrayChangeEndian(msg2_sign_gb_ga);

                                                            // generate msg2_header: lengthis 8 bytes {type, status, size, align, body[]}
                                                            var msg2_head = new Uint8Array(8);
                                                            
                                                            var msg2_head_type = new Uint8Array(1); 
                                                            msg2_head_type.set([1],0);
                                                            msg2_head.set(msg2_head_type,0)          // add type Uint8Array(1) to msg2_head 
                                                            
                                                            var msg2_head_status = new Uint8Array(2);
                                                            msg2_head_status.set([0,0],0);
                                                            msg2_head.set(msg2_head_status, msg2_head_type.byteLength);// add status Uint8Array(2) to msg2_head 

                                                            var msg2_head_size = new Uint32Array(1);
                                                            msg2_head_size.set([168],0);
                                                            var msg2_head_size_Uint8 = new Uint8Array(msg2_head_size.buffer);

                                                            msg2_head.set(msg2_head_size_Uint8, msg2_head_type.byteLength+msg2_head_status.byteLength);

                                                            var msg2_head_align = new Uint8Array(1);
                                                            msg2_head.set(msg2_head_align, msg2_head_type.byteLength+msg2_head_size_Uint8.byteLength);

                                                            console.log("msg2_head");
                                                            console.log(msg2_head);

                                                            // generate msg2: length is 168 bytes {gb, spid, quote_type, kdf_id, sign_gb_ga, mac, sig_rl_size}
                                                            var msg2 = new Uint8Array(168);
                                                            msg2.set(unitArrayChangeEndian(gb),0)// add gb Uint8Array(64) to msg2 gb is now little-endiness
                                                            var msg2_spid = new Uint8Array(16); 
                                                            msg2_spid.set(convertStringToArrayBufferView("Service X"),0);
                                                            msg2.set(msg2_spid, gb.byteLength); // add spid Uint8Array(16) to msg2

                                                            var msg2_quote_type = new Uint16Array(1) // 1: linkable, 0 unlinkable
                                                            msg2_quote_type.set([1], 0);
                                                            var msg2_quote_type_Uint8 = new Uint8Array(msg2_quote_type.buffer);
                                                            msg2.set(msg2_quote_type_Uint8,gb.byteLength+msg2_spid.byteLength); // add quote_type Uint8Array(2) to msg2

                                                            var msg2_kdf_id = new Uint16Array(1);
                                                            msg2_kdf_id.set([1], 0);
                                                            var msg2_kdf_id_Uint8 = new Uint8Array(msg2_kdf_id.buffer);
                                                            msg2.set(msg2_kdf_id_Uint8, gb.byteLength+msg2_spid.byteLength+msg2_quote_type_Uint8.byteLength); // add kdf_id Uint8Array(2) to msg2 

                                                            msg2.set(msg2_sign_gb_ga_little_endian, gb.byteLength+msg2_spid.byteLength+msg2_quote_type_Uint8.byteLength+msg2_kdf_id_Uint8.byteLength);// change msg2_sign_gb_ga to msg2_sign_gb_ga_little_endian 

                                                            // Generate the CMACsmk for gb||SPID||TYPE||kdf_id||Sigsp(gb,ga)
                                                            var msg2_to_be_maced = new Uint8Array(148);
                                                            msg2_to_be_maced.set(msg2.subarray(0,148), 0);
                                                            console.log(msg2_to_be_maced);

                                                            var mac = hexStringToByte(CryptoJS.CMAC(C_smk_key, byteToHexString(msg2_to_be_maced)).toString());
                                                            console.log("generated mac:");
                                                            // console.log(mac);
                                                            console.log(mac);

                                                            msg2.set(mac, gb.byteLength+msg2_spid.byteLength+msg2_quote_type_Uint8.byteLength+msg2_kdf_id_Uint8.byteLength+msg2_sign_gb_ga.byteLength);

                                                            var msg2_sig_rl_size = new Uint32Array(1);
                                                            var msg2_sig_rl_size_Uint8 = new Uint8Array(msg2_sig_rl_size.buffer);

                                                            msg2.set(msg2_sig_rl_size_Uint8, gb.byteLength+msg2_spid.byteLength+msg2_quote_type_Uint8.byteLength+msg2_kdf_id_Uint8.byteLength+msg2_sign_gb_ga.byteLength+mac.byteLength);

                                                            console.log("msg2");
                                                            console.log(msg2);

                                                            // concate msg2_head and msg2
                                                            var msg2_full = new Uint8Array(176)// 8+168
                                                            msg2_full.set(msg2_head,0);
                                                            msg2_full.set(msg2, msg2_head.byteLength);

                                                            console.log("msg2_full");
                                                            console.log(msg2_full);
                                                            var hexstring_msg2 = byteToHexString(msg2_full);
                                                            console.log(hexstring_msg2);

                                                            var msg2_request_data = {
                                                                'length': 176,
                                                                'msg2': hexstring_msg2,

                                                            };
                                                           
                                                            // send msg2 
                                                            $.ajax({
                                                                type: "POST",
                                                                url: "send_MSG2.php",
                                                                data: msg2_request_data,
                                                                dataType: "JSON",
                                                                success: function(response) {

                                                                    console.log(response);

                                                                },
                                                                error: function(jqXHR, textStatus, errorThrown) {
                                                                    console.log(textStatus, errorThrown);
                                                                }


                                                            }); // send msg2 to server
                                                        })
                                                        .catch(function(err) {
                                                            console.log("sign gb_ga error");
                                                            console.error(err);
                                                        });

                                                })
                                                .catch(function(err) {
                                                    console.log("import private key error");
                                                    console.error(err);
                                                });



                                        }).catch = function(e) {
                                            console.log("derived shared key error");
                                            console.log(e.message);
                                        }
                                })
                                .catch(function(e) {
                                    console.log("import public key error")
                                    console.error(e);
                                });

                        } else {
                            alert("Cryptography API not Supported");
                        }

                    },
                    error: function(xhr, textStatus, errorThrown) {
                        console.log('ajax loading error...');
                        return false;
                    }
                });

            }); // end of Client

        });
    </script>
</body>

</html>